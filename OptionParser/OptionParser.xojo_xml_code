<?xml version="1.0" encoding="UTF-8"?>
<RBProject version="2015r3.1" FormatVersion="2" MinIDEVersion="20070100">
<block type="Module" ID="634229026">
 <ObjName>OptionParser</ObjName>
 <ObjContainerID>519440383</ObjContainerID>
 <IsClass>1</IsClass>
 <ItemFlags>1</ItemFlags>
 <IsInterface>0</IsInterface>
 <Compatibility></Compatibility>
 <Method>
  <ItemName>AddOption</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub AddOption(o As Option)</SourceLine>
   <SourceLine>// Add an option to the parser.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>// * `o` - `Option` to add</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Exceptions</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// `OptionParserException` can be thrown if one attempts to add an option with the same</SourceLine>
   <SourceLine>// short or long key as an existing option.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Validation</SourceLine>
   <SourceLine>If o.ShortKey &lt;&gt; "" And Dict.HasKey(o.ShortKey.Asc) Then</SourceLine>
   <SourceLine>Raise New OptionParserException("You can't add the same short key more than once: " + o.ShortKey)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>If o.LongKey &lt;&gt; "" And Dict.HasKey(o.LongKey) Then</SourceLine>
   <SourceLine>Raise New OptionParserException("You can't add the same long key more than once: " + o.LongKey)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>If o.ShortKey = "?" Then</SourceLine>
   <SourceLine>Raise New OptionParserException("You can't add the key ""?"" This means ""help"" and has already been added for you")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Options.Append o</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If o.ShortKey &lt;&gt; "" Then</SourceLine>
   <SourceLine>Dict.Value(o.ShortKey.Asc) = o</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If o.LongKey &lt;&gt; "" Then</SourceLine>
   <SourceLine>Dict.Value(o.LongKey) = o</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>o As Option</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Arguments</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Arguments() As String()</SourceLine>
   <SourceLine>// Get the original arguments passed to the `OptionParser` as</SourceLine>
   <SourceLine>// a `String` array.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return CopyStringArray(OriginalArgs)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>BooleanValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function BooleanValue(key As Variant, defaultValue As Boolean = False) As Boolean</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Retrieve the contents of an option as a `Boolean` value.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `key` - Key of the option to retrieve. This can be the short or long key. Convention</SourceLine>
   <SourceLine>//   is to use the long key if available as it produces more readable code.</SourceLine>
   <SourceLine>// * `defaultValue` - Value to return if the user did not supply this option.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// The option type must be that of `OptionType.Boolean`.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim o As Option = OptionValue(key)</SourceLine>
   <SourceLine>Return If(o Is Nil Or o.WasSet = False, defaultValue, o.Value.BooleanValue)</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As Variant, defaultValue As Boolean = False</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>Constructor</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Constructor(appName As String = "", appDescription As String = "")</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Construct a new `OptionParser`</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `appName` - Name of the application to display when showing help.</SourceLine>
   <SourceLine>// * `appDescription` - Description of the application to display when showing help.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// For more inforation on the parameters, see the two properties `AppName` and `AppDescription`.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// When creating a new `OptionParser` the "Help" option is added automatically. The "Help"</SourceLine>
   <SourceLine>// option uses the short key `h` and the long key `help`, thus they can not be used by</SourceLine>
   <SourceLine>// the application.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dict = New Dictionary</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Self.AppName = If(appName = "", App.ExecutableFile.Name, appName)</SourceLine>
   <SourceLine>Self.AppDescription = appDescription</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim helpOption As New Option("h", "help", "Show help", Option.OptionType.Boolean)</SourceLine>
   <SourceLine>AddOption  helpOption</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>appName As String = "", appDescription As String = ""</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>CopyStringArray</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function CopyStringArray(arr() As String) As String()</SourceLine>
   <SourceLine>Dim result() As String</SourceLine>
   <SourceLine>If arr.Ubound = -1 Then Return result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ReDim result(arr.Ubound)</SourceLine>
   <SourceLine>For i As Integer = 0 to arr.Ubound</SourceLine>
   <SourceLine>result(i) = arr(i)</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return result</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>arr() As String</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>DateValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function DateValue(key As Variant, defaultValue As Date = Nil) As Date</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Retrieve the contents of an option as a `Date` value.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `key` - Key of the option to retrieve. This can be the short or long key. Convention</SourceLine>
   <SourceLine>//   is to use the long key if available as it produces more readable code.</SourceLine>
   <SourceLine>// * `defaultValue` - Value to return if the user did not supply this option.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// The option type must be that of `OptionType.Date`.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// **WARNING**:</SourceLine>
   <SourceLine>// If the `Option.IsValidDateRequired` is set to `True` then the value supplied must</SourceLine>
   <SourceLine>// pass the test of `ParseDate()`. If, however, `Option.IsValidDateRequired` is</SourceLine>
   <SourceLine>// set to `False` and `ParseDate()` can not handle the date properly, the value is</SourceLine>
   <SourceLine>// recorded as a `String` not a `Date`.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// This behavior is likely to change in the future. If one requests the type be a</SourceLine>
   <SourceLine>// valid date, then the value will have to pass as a valid date or a `OptionInvalidKeyValueException`</SourceLine>
   <SourceLine>// will be raised to indicate that an invalid option value has been supplied.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim v As Variant = Value(key)</SourceLine>
   <SourceLine>Return If(v Is Nil, defaultValue, v.DateValue)</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As Variant, defaultValue As Date = Nil</ItemParams>
  <ItemResult>Date</ItemResult>
 </Method>
 <Method>
  <ItemName>DoubleValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function DoubleValue(key As Variant, defaultValue As Double = 0.0) As Double</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Retrieve the contents of an option as a `Double` value.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `key` - Key of the option to retrieve. This can be the short or long key. Convention</SourceLine>
   <SourceLine>//   is to use the long key if available as it produces more readable code.</SourceLine>
   <SourceLine>// * `defaultValue` - Value to return if the user did not supply this option.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// The option type must be that of `OptionType.Double`.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim v As Variant = Value(key)</SourceLine>
   <SourceLine>Return If(v Is Nil, defaultValue, v.DoubleValue)</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As Variant, defaultValue As Double = 0.0</ItemParams>
  <ItemResult>Double</ItemResult>
 </Method>
 <Method>
  <ItemName>ExpandArgs</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ExpandArgs(args() As String) As String()</SourceLine>
   <SourceLine>// Takes arguments that may be chained and expands them</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim expandedArgs() As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For argIndex As Integer = 0 To args.Ubound</SourceLine>
   <SourceLine>Dim arg As String = args(argIndex)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If arg = "--" Then</SourceLine>
   <SourceLine>// Start of our "forced" extras</SourceLine>
   <SourceLine>For i As Integer = argIndex To args.Ubound</SourceLine>
   <SourceLine>expandedArgs.Append args(i)</SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Exit For argIndex</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf arg.Left(2) = "--" Then</SourceLine>
   <SourceLine>expandedArgs.Append arg</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf arg.Left(1) = "-" And arg.Len &gt; 2 Then</SourceLine>
   <SourceLine>arg = arg.Mid(2) // Chop off the hyphen</SourceLine>
   <SourceLine>Dim value As String</SourceLine>
   <SourceLine>Dim equalIndex As Integer = arg.InStr(2, "=") // If they started the switch with "=", that doesn't count</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If equalIndex &lt;&gt; 0 Then</SourceLine>
   <SourceLine>value = arg.Mid(equalIndex)</SourceLine>
   <SourceLine>arg = arg.Left(equalIndex - 1)</SourceLine>
   <SourceLine>End if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim switches() As String = arg.Split("")</SourceLine>
   <SourceLine>Dim lastIndex As Integer = switches.Ubound - 1</SourceLine>
   <SourceLine>For i As Integer = 0 To lastIndex</SourceLine>
   <SourceLine>expandedArgs.Append "-" + switches(i)</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine>expandedArgs.Append "-" + switches(switches.Ubound) + value</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else // Append as-is</SourceLine>
   <SourceLine>expandedArgs.Append arg</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next argIndex</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return expandedArgs</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>args() As String</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>FileValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function FileValue(key As Variant, defaultValue As FolderItem = Nil) As FolderItem</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Retrieve the contents of an option as a `FolderItem` value.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `key` - Key of the option to retrieve. This can be the short or long key. Convention</SourceLine>
   <SourceLine>//   is to use the long key if available as it produces more readable code.</SourceLine>
   <SourceLine>// * `defaultValue` - Value to return if the user did not supply this option.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// The option type must be that of `OptionType.File` or `OptionType.Folder`.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// **WARNING**:</SourceLine>
   <SourceLine>// This will likely be renamed to `FolderItemValue` in the future.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim v As Variant = Value(key)</SourceLine>
   <SourceLine>Return If(v Is Nil, defaultValue, FolderItem(v))</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As Variant, defaultValue As FolderItem = Nil</ItemParams>
  <ItemResult>FolderItem</ItemResult>
 </Method>
 <Method>
  <ItemName>IntegerValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function IntegerValue(key As Variant, defaultValue As Integer = 0) As Integer</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Retrieve the contents of an option as a `Integer` value.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `key` - Key of the option to retrieve. This can be the short or long key. Convention</SourceLine>
   <SourceLine>//   is to use the long key if available as it produces more readable code.</SourceLine>
   <SourceLine>// * `defaultValue` - Value to return if the user did not supply this option.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// The option type must be that of `OptionType.Integer`.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim v As Variant = Value(key)</SourceLine>
   <SourceLine>Return If(v Is Nil, defaultValue, v.IntegerValue)</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As Variant, defaultValue As Integer = 0</ItemParams>
  <ItemResult>Integer</ItemResult>
 </Method>
 <Method>
  <ItemName>KeyWithDashes</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function KeyWithDashes(key As String) As String</SourceLine>
   <SourceLine>// Takes a key and converts it back to its single or double-dash version</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>key = key.Trim</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If key = "" Then</SourceLine>
   <SourceLine>Return ""</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf key.Left(1) = "-" Then // Already there</SourceLine>
   <SourceLine>Return key</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf key.Len = 1 Then</SourceLine>
   <SourceLine>Return "-" + key</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Return "--" + key</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As String</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>OptionValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function OptionValue(key As String) As Option</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Retrieve the actual `Option` object associated with the `key`.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `key` - Key of the option to retrieve. This can be the short or long key. Convention</SourceLine>
   <SourceLine>//   is to use the long key if available as it produces more readable code.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Once `Parse` has been called, changing parameters in the `Option` object will</SourceLine>
   <SourceLine>// have no bearing or change.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// One can use this to check the `WasSet` property of the `Option` class.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim lookupKey As Variant = key</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If Not Dict.HasKey(lookupKey) Then</SourceLine>
   <SourceLine>If key.Len = 1 Then</SourceLine>
   <SourceLine>lookupKey = key.Asc</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return Dict.Lookup(lookupKey, Nil)</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As String</ItemParams>
  <ItemResult>Option</ItemResult>
 </Method>
 <Method>
  <ItemName>PadRight</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function PadRight(s as String, width as Integer, padding as String = " ") As String</SourceLine>
   <SourceLine>// Pad a string to at least 'width' characters, by adding padding characters</SourceLine>
   <SourceLine>// to the right side of the string.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim length as Integer</SourceLine>
   <SourceLine>length = len(s)</SourceLine>
   <SourceLine>if length &gt;= width then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim mostToRepeat as Integer</SourceLine>
   <SourceLine>mostToRepeat = ceil((width-length)/len(padding))</SourceLine>
   <SourceLine>return s + mid(Repeat(padding, mostToRepeat),1,width-length)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s as String, width as Integer, padding as String = " "</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Parse</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub Parse(args() As String, firstArgIsExecutable As Boolean = True)</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Parse the arguments</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>// </SourceLine>
   <SourceLine>// * `args()` - Command line arguments already split into an array. Generally this will be used</SourceLine>
   <SourceLine>//   with a `ConsoleApplication` since it's `Run` event passes in command line parameters this way.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Exceptions</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `OptionUnrecognizedKeyException` can be raised in the event an invalid argument is supplied.</SourceLine>
   <SourceLine>//    For example, the user types `myprog --coun=12` when it should have been `--count=12`.</SourceLine>
   <SourceLine>// * `OptionInvalidKeyValueException` can be raised in the event a valid argument is supplied with</SourceLine>
   <SourceLine>//   an invalid value. For example `--count=John` where `count` was suppose to be an `Integer`.</SourceLine>
   <SourceLine>// * `OptionParserException` can be raised in the event that the application expects at least X</SourceLine>
   <SourceLine>//   extra items but the user did not supply at least X extra items.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>OriginalArgs = CopyStringArray(args)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>args = ExpandArgs(args)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim restAreExtras As Boolean</SourceLine>
   <SourceLine>Dim optIdx As Integer = -1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>While optIdx &lt; args.Ubound // args can be rewritten in the loop</SourceLine>
   <SourceLine>optIdx = optIdx + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// If the first argument is the executable,</SourceLine>
   <SourceLine>// we simply ignore it</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if optIdx = 0 and firstArgIsExecutable then</SourceLine>
   <SourceLine>continue while</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If restAreExtras Then</SourceLine>
   <SourceLine>Extra.Append args(optIdx)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Continue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim arg As String = args(optIdx)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If arg = "" Then</SourceLine>
   <SourceLine>Continue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If arg = "--" Then</SourceLine>
   <SourceLine>restAreExtras = True</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Continue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim key As String</SourceLine>
   <SourceLine>Dim value As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Special case:</SourceLine>
   <SourceLine>// -? is a synonym for help</SourceLine>
   <SourceLine>If arg.Left(2) = "-?" Then</SourceLine>
   <SourceLine>arg = "-h" + arg.Mid(3)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If arg.Left(2) = "--" Then</SourceLine>
   <SourceLine>key = arg.Mid(3)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf arg.Left(1) = "-" Then</SourceLine>
   <SourceLine>key = arg.Mid(2)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>If arg &lt;&gt; "" Then</SourceLine>
   <SourceLine>Extra.Append arg</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Continue</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim equalIdx As Integer = key.InStr(2, "=") // Start at the second character</SourceLine>
   <SourceLine>dim hasEquals as boolean</SourceLine>
   <SourceLine>If equalIdx &lt;&gt; 0 Then</SourceLine>
   <SourceLine>hasEquals = true</SourceLine>
   <SourceLine>value = key.Mid(equalIdx + 1)</SourceLine>
   <SourceLine>key = key.Left(equalIdx - 1)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim opt As Option = OptionValue(key)</SourceLine>
   <SourceLine>If opt = Nil Then</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Maybe the user has specified --no-option which should set a</SourceLine>
   <SourceLine>// boolean value to False</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If key.Left(3) &lt;&gt; "no-" Then</SourceLine>
   <SourceLine>RaiseUnrecognizedKeyException(key)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>key = key.Mid(4)</SourceLine>
   <SourceLine>opt = OptionValue(key)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If opt = Nil Or opt.Type &lt;&gt; Option.OptionType.Boolean Then</SourceLine>
   <SourceLine>RaiseUnrecognizedKeyException(key)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>value = "No"</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If value &lt;&gt; "" or hasEquals Then</SourceLine>
   <SourceLine>// We already got the value, ignore everything else in this If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf opt.Type = Option.OptionType.Boolean Then</SourceLine>
   <SourceLine>value = "Yes"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf Not Self.HelpRequested Then</SourceLine>
   <SourceLine>// This requires a parameter and the parameter value was not</SourceLine>
   <SourceLine>// given as an = assignment, thus it must be the next argument</SourceLine>
   <SourceLine>// But if help was requested, it doesn't matter, so we skip this.</SourceLine>
   <SourceLine>// If a value was given next, it will just be added to Extras.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If optIdx = args.Ubound Then</SourceLine>
   <SourceLine>RaiseInvalidKeyValueException(key, kMissingKeyValue)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>optIdx = optIdx + 1</SourceLine>
   <SourceLine>value = args(optIdx)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>opt.HandleValue(value)</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Validate Parsed Values</SourceLine>
   <SourceLine>// but only if help wasn't requested.</SourceLine>
   <SourceLine>// If it was, all bets are off and up to the caller to validate.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If Not Self.HelpRequested Then</SourceLine>
   <SourceLine>If ExtrasRequired &gt; 0 And Extra.Ubound &lt; (ExtrasRequired - 1) Then</SourceLine>
   <SourceLine>Raise New OptionParserException("Insufficient extras specified")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For Each o As Option In Options</SourceLine>
   <SourceLine>If Not o.IsValid Then</SourceLine>
   <SourceLine>Dim key As String</SourceLine>
   <SourceLine>If o.LongKey &lt;&gt; "" Then</SourceLine>
   <SourceLine>key = o.LongKey</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>key = o.ShortKey</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If o.IsRequired And o.Value = Nil Then</SourceLine>
   <SourceLine>RaiseMissingKeyException(key)</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>RaiseInvalidKeyValueException(key, kInvalidKeyValue + " '" + o.Value.StringValue + "'")</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>args() As String, firstArgIsExecutable As Boolean = True</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>ParseStringValue</ItemName>
  <Compatibility>(TargetHasGUI)</Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Shared Function ParseStringValue(value As String) As String()</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Parse the arguments into a `String` array of parameters, then pass the contents of that</SourceLine>
   <SourceLine>// array to the 'real' `Parse(args() As String)` method.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `value` - Command line arguments contained in a single line string. This is </SourceLine>
   <SourceLine>//   used in a Desktop via a call to `System.CommandLine` as a Desktop</SourceLine>
   <SourceLine>//   has no direct access to the `args()` parameter that a `ConsoleApplication`</SourceLine>
   <SourceLine>//   does.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// See `Parse(args() As String)` for more detailed information</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim matches() As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim rx As New RegEx</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>'#if TargetWin32 then</SourceLine>
   <SourceLine>'</SourceLine>
   <SourceLine>'// Code from Michel Bujardet (https://forum.xojo.com/14420-system-commandline)</SourceLine>
   <SourceLine>'</SourceLine>
   <SourceLine>'rx.SearchPattern = "(""[^""]+""|[^\s""]+)"</SourceLine>
   <SourceLine>'</SourceLine>
   <SourceLine>'Dim match As RegExMatch = rx.Search(value)</SourceLine>
   <SourceLine>'</SourceLine>
   <SourceLine>'While match &lt;&gt; Nil</SourceLine>
   <SourceLine>'matches.Append ReplaceAll(match.SubExpressionString(1), chr(34), "")</SourceLine>
   <SourceLine>'match = rx.Search()</SourceLine>
   <SourceLine>'Wend</SourceLine>
   <SourceLine>'</SourceLine>
   <SourceLine>'#else // TargetDesktop</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// We have to peel off of the executable first</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim rest as string</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim myPath as string = App.ExecutableFile.NativePath</SourceLine>
   <SourceLine>dim pattern as string = """?(\Q" + myPath.ReplaceAllB( "\E", "\\EE\Q" ) + "\E)""? (.*)"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>rx.SearchPattern = pattern</SourceLine>
   <SourceLine>dim match as RegExMatch = rx.Search(value)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if match IsA RegExMatch then</SourceLine>
   <SourceLine>matches.Append match.SubExpressionString(1)</SourceLine>
   <SourceLine>rest = match.SubExpressionString(2)</SourceLine>
   <SourceLine>ParseRestOfString(rest, matches)</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>matches.Append value</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>'#endif</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return(matches)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>1</IsShared>
  <ItemParams>value As String</ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>RaiseInvalidKeyValueException</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub RaiseInvalidKeyValueException(key As String, type As String)</SourceLine>
   <SourceLine>Raise New OptionInvalidKeyValueException("Invalid key value: " + KeyWithDashes(key) + " (" + type + ")")</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As String, type As String</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>RaiseMissingKeyException</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub RaiseMissingKeyException(key As String)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Raise New OptionMissingKeyException("Missing option: " + KeyWithDashes(key))</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As String</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>RaiseUnrecognizedKeyException</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub RaiseUnrecognizedKeyException(key As String)</SourceLine>
   <SourceLine>Raise New OptionUnrecognizedKeyException("Unrecognized key: " + KeyWithDashes(key))</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As String</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>Repeat</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Repeat(s as String, repeatCount as Integer) As String</SourceLine>
   <SourceLine>// Concatenate a string to itself 'repeatCount' times.</SourceLine>
   <SourceLine>// Example: Repeat("spam ", 5) = "spam spam spam spam spam ".</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#pragma disablebackgroundTasks</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if repeatCount &lt;= 0 then return ""</SourceLine>
   <SourceLine>if repeatCount = 1 then return s</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Implementation note: normally, you don't want to use string concatenation</SourceLine>
   <SourceLine>// for something like this, since that creates a new string on each operation.</SourceLine>
   <SourceLine>// But in this case, we can double the size of the string on iteration, which</SourceLine>
   <SourceLine>// quickly reduces the overhead of concatenation to insignificance.  This method</SourceLine>
   <SourceLine>// is faster than any other we've found (short of declares, which were only</SourceLine>
   <SourceLine>// about 2X faster and were quite platform-specific).</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim desiredLenB As Integer = LenB(s) * repeatCount</SourceLine>
   <SourceLine>dim output as String = s</SourceLine>
   <SourceLine>dim cutoff as Integer = (desiredLenB+1)\2</SourceLine>
   <SourceLine>dim curLenB as Integer = LenB(output)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>while curLenB &lt; cutoff</SourceLine>
   <SourceLine>output = output + output</SourceLine>
   <SourceLine>curLenB = curLenB + curLenB</SourceLine>
   <SourceLine>wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>output = output + LeftB(output, desiredLenB - curLenB)</SourceLine>
   <SourceLine>return output</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>s as String, repeatCount as Integer</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>ShowHelp</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub ShowHelp(sectionTitle As String = "Help")</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Display a nicely formatted help message including various pieces of meta</SourceLine>
   <SourceLine>// data such as `AppName`, `AppDescription` and `AdditionalHelpNotes`. Mixed</SourceLine>
   <SourceLine>// in there are of course all of the possible options with their short and long</SourceLine>
   <SourceLine>// keys, value types (if any) and description</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>// * `sectionTitle` - One can overide the section title in case they have multiple</SourceLine>
   <SourceLine>//   help screen outputs or have utilized more than one `OptionParser` for some</SourceLine>
   <SourceLine>//   advanced techniques.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Right now there is not a nice GUI for displaying the command line help for</SourceLine>
   <SourceLine>// a GUI application or a Web application.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * For a console application, the output is `Print` to the screen.</SourceLine>
   <SourceLine>// * For a GUI application, the output is given to `MsgBox`</SourceLine>
   <SourceLine>// * For a Web application, help is not currently displayed.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// **WARNING**: It is likely that for console applications the call to `Print`</SourceLine>
   <SourceLine>// will changes to `StdErr.Write` instead.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Const kAlignCol = 20</SourceLine>
   <SourceLine>Const kLineLength = 72</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Static descIndent As String = kIndentPrefix + Repeat(" ", kAlignCol + 1)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim helpLines() As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim helpFor As String = AppName</SourceLine>
   <SourceLine>If helpFor &lt;&gt; "" Then</SourceLine>
   <SourceLine>If AppDescription &lt;&gt; "" Then</SourceLine>
   <SourceLine>helpFor = kIndentPrefix + helpFor + " - " + AppDescription</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>helpLines.Append WrapTextWithIndent(helpFor, kLineLength)</SourceLine>
   <SourceLine>helpLines.Append ""</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>helpLines.Append sectionTitle + ":"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For i As Integer = 0 To Options.Ubound</SourceLine>
   <SourceLine>Dim opt As Option = Options(i)</SourceLine>
   <SourceLine>Dim keys() As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If opt.ShortKey &lt;&gt; "" Then</SourceLine>
   <SourceLine>Dim keyString As String = KeyWithDashes(opt.ShortKey)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If opt.Type &lt;&gt; Option.OptionType.Boolean Then</SourceLine>
   <SourceLine>keyString = keyString + " " + opt.TypeString</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>keys.Append keyString</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If opt.LongKey &lt;&gt; "" Then</SourceLine>
   <SourceLine>Dim keyString As String = KeyWithDashes(opt.LongKey)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If opt.Type &lt;&gt; Option.OptionType.Boolean Then</SourceLine>
   <SourceLine>keyString = keyString + "=" + opt.TypeString</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>keys.Append keyString</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim key As String = Join(keys, ", ")</SourceLine>
   <SourceLine>dim desc as string = opt.HelpDescription</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If key.Len &gt; kAlignCol Or desc.InStr(EndOfLine) &lt;&gt; 0 Then</SourceLine>
   <SourceLine>helpLines.Append kIndentPrefix + key</SourceLine>
   <SourceLine>helpLines.Append WrapTextWithIndent(desc, kLineLength, descIndent)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf (key.Len + desc.Len) &gt; kLineLength Then</SourceLine>
   <SourceLine>key = kIndentPrefix + PadRight(key, kAlignCol + 1)</SourceLine>
   <SourceLine>desc = WrapTextWithIndent(desc, kLineLength, descIndent)</SourceLine>
   <SourceLine>desc = desc.Mid(key.Len + 1)</SourceLine>
   <SourceLine>helpLines.Append key + desc</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>helpLines.Append kIndentPrefix + PadRight(key, kAlignCol + 1) + desc </SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim notes As String = AdditionalHelpNotes.Trim</SourceLine>
   <SourceLine>If notes &lt;&gt; "" Then</SourceLine>
   <SourceLine>notes = WrapTextWithIndent(notes, kLineLength)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>helpLines.Append ""</SourceLine>
   <SourceLine>helpLines.Append "Notes:"</SourceLine>
   <SourceLine>helpLines.Append notes</SourceLine>
   <SourceLine>helpLines.Append ""</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim help As String = Join(helpLines, EndOfLine)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#If TargetConsole Then</SourceLine>
   <SourceLine>Print help</SourceLine>
   <SourceLine>#ElseIf TargetDesktop Then</SourceLine>
   <SourceLine>MsgBox help</SourceLine>
   <SourceLine>#Else</SourceLine>
   <SourceLine>#Pragma Warning "How to print help?"</SourceLine>
   <SourceLine>#EndIf</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>sectionTitle As String = "Help"</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>StringValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function StringValue(key As Variant, defaultValue As String = "") As String</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Retrieve the contents of an option as a `String` value.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `key` - Key of the option to retrieve. This can be the short or long key. Convention</SourceLine>
   <SourceLine>//   is to use the long key if available as it produces more readable code.</SourceLine>
   <SourceLine>// * `defaultValue` - Value to return if the user did not supply this option.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// The option type must be that of `OptionType.String`.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim o As Option = OptionValue(key)</SourceLine>
   <SourceLine>Return If(o Is Nil Or o.WasSet = False Or o.Value Is Nil, defaultValue, o.Value.StringValue)</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As Variant, defaultValue As String = ""</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>Value</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function Value(key As Variant) As Variant</SourceLine>
   <SourceLine>Dim vk As String = key</SourceLine>
   <SourceLine>Dim v As Variant = Dict.Lookup(vk, Nil)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If v = Nil Then</SourceLine>
   <SourceLine>v = Dict.Lookup(vk.Asc, Nil)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If v &lt;&gt; Nil Then</SourceLine>
   <SourceLine>Return Option(v).Value</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return Nil</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As Variant</ItemParams>
  <ItemResult>Variant</ItemResult>
 </Method>
 <Method>
  <ItemName>WrapLines</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub WrapLines(lines() As String, charsPerLine As Integer = 72, paragraphFill As Boolean = true)</SourceLine>
   <SourceLine>// Wrap the text so that no line is longer than charsPerLine.  If paragraphFill</SourceLine>
   <SourceLine>// is true, then whenever one long line is followed by a line that does not</SourceLine>
   <SourceLine>// start with whitespace, join them together into one continuous paragraph.</SourceLine>
   <SourceLine>// Copied from StringUtils.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If UBound(lines) &lt; 0 Then Return</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Start by joining lines, if called for.</SourceLine>
   <SourceLine>If paragraphFill Then</SourceLine>
   <SourceLine>Dim lineNum As Integer = 1</SourceLine>
   <SourceLine>Dim lastLineShort As Boolean = (lines(0).Len &lt; charsPerLine - 20)</SourceLine>
   <SourceLine>While lineNum &lt;= UBound(lines)</SourceLine>
   <SourceLine>Dim line As String = lines(lineNum)</SourceLine>
   <SourceLine>Dim firstChar As String = Left(line, 1)</SourceLine>
   <SourceLine>If lastLineShort Then</SourceLine>
   <SourceLine>// last line was short, so don't join this one to it</SourceLine>
   <SourceLine>lineNum = lineNum + 1</SourceLine>
   <SourceLine>elseif line = "" or firstChar &lt;= " " or firstChar = "&gt;" or firstChar = "|" Then</SourceLine>
   <SourceLine>// this line is empty or starts with whitespace or other special char; don't join it</SourceLine>
   <SourceLine>lineNum = lineNum + 1</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>// this line starts with a character; join it to the previous line</SourceLine>
   <SourceLine>lines(lineNum - 1) = lines(lineNum - 1) + " " + line</SourceLine>
   <SourceLine>lines.Remove lineNum</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>lastLineShort = (line.Len &lt; charsPerLine - 20)</SourceLine>
   <SourceLine>Wend</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// Then, go through and do the wrapping.</SourceLine>
   <SourceLine>For lineNum As Integer = 0 To UBound(lines)</SourceLine>
   <SourceLine>Dim line As String = RTrim(lines(lineNum))</SourceLine>
   <SourceLine>If line.Len &lt;= charsPerLine Then</SourceLine>
   <SourceLine>lines(lineNum) = line</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Dim breakPos As Integer</SourceLine>
   <SourceLine>For breakPos = charsPerLine DownTo 1</SourceLine>
   <SourceLine>Dim c As String = Mid(line, breakPos, 1)</SourceLine>
   <SourceLine>If c &lt;= " " or c = "-" Then Exit</SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine>If breakPos &lt; 2 Then breakPos = charsPerLine + 1 // no point breaking before char 1</SourceLine>
   <SourceLine>lines.Insert lineNum + 1, LTrim(Mid(line, breakPos))</SourceLine>
   <SourceLine>lines(lineNum) = LTrim(Left(line, breakPos - 1))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>lines() As String, charsPerLine As Integer = 72, paragraphFill As Boolean = true</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>WrapLinesWithIndent</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Sub WrapLinesWithIndent(lines() As String, charsPerLine As Integer, indent As String = kIndentPrefix)</SourceLine>
   <SourceLine>WrapLines(lines, charsPerLine - indent.Len, False)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>For i As Integer = 0 To lines.Ubound</SourceLine>
   <SourceLine>lines(i) = indent + lines(i)</SourceLine>
   <SourceLine>Next i</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>lines() As String, charsPerLine As Integer, indent As String = kIndentPrefix</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>WrapTextWithIndent</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function WrapTextWithIndent(text As String, charsPerLine As Integer, indent As String = kIndentPrefix) As String</SourceLine>
   <SourceLine>text = ReplaceLineEndings(text, EndOfLine)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim lines() As String = Split(text, EndOfLine)</SourceLine>
   <SourceLine>WrapLinesWithIndent(lines, charsPerLine, indent)</SourceLine>
   <SourceLine>Return Join(lines, EndOfLine)</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>text As String, charsPerLine As Integer, indent As String = kIndentPrefix</ItemParams>
  <ItemResult>String</ItemResult>
 </Method>
 <Method>
  <ItemName>ArrayValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Function ArrayValue(key As Variant) As Variant()</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Retrieve the contents of an option as a `Variant` array. The contents</SourceLine>
   <SourceLine>// of the array are of course a `Variant` however the actual value assigned to the</SourceLine>
   <SourceLine>// `Variant` is that of the options `OptionType`. For example, if this option is</SourceLine>
   <SourceLine>// of the `OptionType.Integer` value, then the resulting array will be an array</SourceLine>
   <SourceLine>// containing parsed `Integer` values from the command line. The same is true for</SourceLine>
   <SourceLine>// any of the `OptionType` values.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Parameters</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// * `key` - Key of the option to retrieve. This can be the short or long key. Convention</SourceLine>
   <SourceLine>//   is to use the long key if available as it produces more readable code.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// ### Notes</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// The option needs to have the `IsArray` property set to `True` to utilize this method.</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim v() As Variant</SourceLine>
   <SourceLine>Dim o As Option = OptionValue(key)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If Not (o Is Nil) Then</SourceLine>
   <SourceLine>v = o.Value</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return v</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <ItemParams>key As Variant</ItemParams>
  <ItemResult>Variant()</ItemResult>
 </Method>
 <Method>
  <ItemName>ParseRestOfString</ItemName>
  <Compatibility>(TargetHasGUI)</Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Shared Sub ParseRestOfString(value As String, appendTo() As String)</SourceLine>
   <SourceLine>value = value.Trim</SourceLine>
   <SourceLine>if value = "" then</SourceLine>
   <SourceLine>return</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if value.Encoding = nil then</SourceLine>
   <SourceLine>#if TargetMacOS then</SourceLine>
   <SourceLine>value = value.DefineEncoding(Encodings.MacRoman)</SourceLine>
   <SourceLine>#else</SourceLine>
   <SourceLine>value = value.DefineEncoding(Encodings.ISOLatin1)</SourceLine>
   <SourceLine>#endif</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>value = value.ConvertEncoding( Encodings.UTF8 )</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim allChars() as string = value.Split("")</SourceLine>
   <SourceLine>dim thisChunk() as string</SourceLine>
   <SourceLine>dim inQuote as boolean</SourceLine>
   <SourceLine>dim quoteChar as string</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim charIndex as integer</SourceLine>
   <SourceLine>while charIndex &lt;= allChars.Ubound</SourceLine>
   <SourceLine>dim thisChar as string = allChars(charIndex)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if thisChar = "\" and charIndex &lt; allChars.Ubound then</SourceLine>
   <SourceLine>thisChunk.Append allChars(charIndex + 1)</SourceLine>
   <SourceLine>charIndex = charIndex + 1</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif inQuote and thisChar = quoteChar then</SourceLine>
   <SourceLine>inQuote = false</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif inQuote then</SourceLine>
   <SourceLine>thisChunk.Append thisChar</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif IsQuoteCharacter(thisChar) then</SourceLine>
   <SourceLine>inQuote = true</SourceLine>
   <SourceLine>quoteChar = thisChar</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>elseif thisChar = " " then</SourceLine>
   <SourceLine>if thisChunk.Ubound &lt;&gt; -1 then</SourceLine>
   <SourceLine>appendTo.Append join(thisChunk, "")</SourceLine>
   <SourceLine>redim thisChunk(-1)</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>else // Just a character</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>thisChunk.Append thisChar</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>charIndex = charIndex + 1</SourceLine>
   <SourceLine>wend</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>if thisChunk.Ubound &lt;&gt; -1 then</SourceLine>
   <SourceLine>appendTo.Append join(thisChunk, "")</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>End Sub</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>1</IsShared>
  <ItemParams>value As String, appendTo() As String</ItemParams>
  <ItemResult></ItemResult>
 </Method>
 <Method>
  <ItemName>IsQuoteCharacter</ItemName>
  <Compatibility>(TargetHasGUI)</Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Shared Function IsQuoteCharacter(char As String) As Boolean</SourceLine>
   <SourceLine>#if TargetWin32 then</SourceLine>
   <SourceLine>return (char = """")</SourceLine>
   <SourceLine>#else</SourceLine>
   <SourceLine>return (char = """" or char = "'")</SourceLine>
   <SourceLine>#endif</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>33</ItemFlags>
  <IsShared>1</IsShared>
  <ItemParams>char As String</ItemParams>
  <ItemResult>Boolean</ItemResult>
 </Method>
 <Method>
  <ItemName>CommandLineArgs</ItemName>
  <Compatibility>(TargetHasGUI)</Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine> Shared Function CommandLineArgs() As String()</SourceLine>
   <SourceLine>// Return an array of command-line arguments</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>const kDebugDeclares = false</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim args() as string</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#if DebugBuild and not kDebugDeclares then </SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Not perfect, but will emulate what you'll get in the built app</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>args = ParseStringValue(System.CommandLine)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#elseif TargetMacOS then</SourceLine>
   <SourceLine>const kCocoaLib = "Cocoa.framework"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>declare function NSClassFromString lib kCocoaLib (aClassName as CFStringRef) as Ptr</SourceLine>
   <SourceLine>declare function defaultCenter lib kCocoaLib selector "processInfo" (class_id as Ptr) as Ptr</SourceLine>
   <SourceLine>declare function arguments lib kCocoaLib selector "arguments" (obj_id as Ptr) as Ptr</SourceLine>
   <SourceLine>declare function m_count lib kCocoaLib selector "count" (obj as Ptr) as UInteger</SourceLine>
   <SourceLine>declare function objectAtIndex lib kCocoaLib selector "objectAtIndex:" (theArray as Ptr, idx as Integer) as CFStringRef</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>static c as Ptr = defaultCenter(NSClassFromString("NSProcessInfo"))</SourceLine>
   <SourceLine>dim nsArrayRef as Ptr = arguments(c)</SourceLine>
   <SourceLine>dim ub as integer = m_count(nsArrayRef) - 1</SourceLine>
   <SourceLine>for i as integer = 0 to ub</SourceLine>
   <SourceLine>dim s as string = objectAtIndex(nsArrayRef, i)</SourceLine>
   <SourceLine>args.Append s</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#elseif TargetWin32 then</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Windows and Linux code from Thomas Tempelmann</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>declare function GetCommandLineW lib "kernel32.dll" () as Ptr</SourceLine>
   <SourceLine>declare function CommandLineToArgvW lib "shell32.dll" (lpCmdLine As Ptr, ByRef pNumArgs As Integer) As Ptr</SourceLine>
   <SourceLine>declare sub LocalFree Lib "kernel32.dll" (p as Ptr)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>dim cl as Ptr = GetCommandLineW()</SourceLine>
   <SourceLine>dim n as Integer</SourceLine>
   <SourceLine>dim argList as Ptr = CommandLineToArgvW (cl, n)</SourceLine>
   <SourceLine>for idx as Integer = 0 to n-1</SourceLine>
   <SourceLine>dim mb as MemoryBlock = argList.Ptr(idx*4)</SourceLine>
   <SourceLine>// mb points to a UTF16 0-terminated string. It seems we have to scan its length ourselves now.</SourceLine>
   <SourceLine>dim len as Integer</SourceLine>
   <SourceLine>while mb.UInt16Value(len) &lt;&gt; 0</SourceLine>
   <SourceLine>len = len + 2</SourceLine>
   <SourceLine>wend</SourceLine>
   <SourceLine>dim s as String = mb.StringValue(0,len).DefineEncoding(Encodings.UTF16)</SourceLine>
   <SourceLine>s = s.ConvertEncoding(Encodings.UTF8)</SourceLine>
   <SourceLine>args.Append s</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine>LocalFree(argList)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#elseif TargetLinux then</SourceLine>
   <SourceLine>// read from "/proc/self/cmdline", each item is 0-terminated</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>const SystemLib = "libc.so"</SourceLine>
   <SourceLine>declare function open lib SystemLib (path as CString, flags as Integer) As Integer</SourceLine>
   <SourceLine>declare function read lib SystemLib (fd as Integer, data as Ptr, n as Integer) as Integer</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>// first, read the entire cmdline into a string</SourceLine>
   <SourceLine>dim fd as Integer = open ("/proc/self/cmdline", 0)</SourceLine>
   <SourceLine>dim s as String</SourceLine>
   <SourceLine>do</SourceLine>
   <SourceLine>dim mb as new MemoryBlock(1000)</SourceLine>
   <SourceLine>dim n as Integer = read (fd, mb, mb.Size)</SourceLine>
   <SourceLine>s = s + mb.StringValue (0, n)</SourceLine>
   <SourceLine>if n &lt; mb.Size then exit</SourceLine>
   <SourceLine>loop</SourceLine>
   <SourceLine>args = s.Split(Chr(0))</SourceLine>
   <SourceLine>call args.Pop // remove last array item because of extra 00 byte at end of string</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>for i as integer = 0 to args.Ubound</SourceLine>
   <SourceLine>dim thisArg as string = args(i)</SourceLine>
   <SourceLine>if Encodings.UTF8.IsValidData(thisArg) then</SourceLine>
   <SourceLine>args(i) = thisArg.DefineEncoding(Encodings.UTF8)</SourceLine>
   <SourceLine>else</SourceLine>
   <SourceLine>args(i) = thisArg.DefineEncoding(Encodings.ISOLatin1)</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine>next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#endif</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>return args</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>1</IsShared>
  <ItemParams></ItemParams>
  <ItemResult>String()</ItemResult>
 </Method>
 <Method>
  <ItemName>GetRelativeFolderItem</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine> Shared Function GetRelativeFolderItem(path As String, relativeTo As FolderItem = Nil) As FolderItem</SourceLine>
   <SourceLine>Dim prefix As String = ""</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#If TargetWin32 Then</SourceLine>
   <SourceLine>Const pathSep = "\"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Maybe what is passed isn't actually a relative path</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If path.Mid(2, 1) = ":" Then</SourceLine>
   <SourceLine>Return GetFolderItem(path, FolderItem.PathTypeShell)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If path.Left(1) = pathSep Then</SourceLine>
   <SourceLine>relativeTo = GetFolderItem(SpecialFolder.CurrentWorkingDirectory.NativePath.Left(3))</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>#Else</SourceLine>
   <SourceLine>Const pathSep = "/"</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Resolve home</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>if path.Left(2) = "~/" then</SourceLine>
   <SourceLine>path = SpecialFolder.UserHome.NativePath + path.Mid(2)</SourceLine>
   <SourceLine>end if</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// Maybe what is passed isn't actually a relative path</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If path.Left(1) = pathSep Then</SourceLine>
   <SourceLine>Return GetFolderItem(path, FolderItem.PathTypeShell)</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>prefix = pathSep</SourceLine>
   <SourceLine>#EndIf</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine>// OK, seems to be a relative path</SourceLine>
   <SourceLine>//</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>If relativeTo = Nil Then</SourceLine>
   <SourceLine>relativeTo = SpecialFolder.CurrentWorkingDirectory</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>path = relativeTo.NativePath + pathSep + path</SourceLine>
   <SourceLine>Dim newParts() As String</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Dim pathParts() As String = path.Split(pathSep)</SourceLine>
   <SourceLine>For i As Integer = 0 to pathParts.Ubound</SourceLine>
   <SourceLine>Dim p As String = pathParts(i)</SourceLine>
   <SourceLine>If p = "" Then</SourceLine>
   <SourceLine>// Can happen on Windows since it appends a pathSep onto the end of NativePath</SourceLine>
   <SourceLine>// if relativeTo is a folder.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf p = "." Then</SourceLine>
   <SourceLine>// Skip this path component</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>ElseIf p = ".." Then</SourceLine>
   <SourceLine>// Remove the last path component from newParts</SourceLine>
   <SourceLine>If newParts.Ubound &gt; -1 Then</SourceLine>
   <SourceLine>newParts.Remove newParts.Ubound</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>// Nothing special about this path component</SourceLine>
   <SourceLine>newParts.Append p</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine>Next</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>path = prefix + Join(newParts, pathSep)</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>Return GetFolderItem(path, FolderItem.PathTypeShell)</SourceLine>
   <SourceLine>End Function</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <AliasName></AliasName>
  <ItemFlags>0</ItemFlags>
  <IsShared>1</IsShared>
  <ItemParams>path As String, relativeTo As FolderItem = Nil</ItemParams>
  <ItemResult>FolderItem</ItemResult>
 </Method>
 <Note>
  <ItemName>Overview</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>Overview</NoteLine>
   <NoteLine>`OptionParser` is the glue between `Option` classes and the command line as supplied via</NoteLine>
   <NoteLine>the `Run` event's `args()` parameter in a `ConsoleApplication` or via a call to </NoteLine>
   <NoteLine>`System.CommandLine` in a Desktop or Web application. It handles actually parsing the</NoteLine>
   <NoteLine>command line, populating the associated `Option`s and validating it as a whole.</NoteLine>
  </ItemSource>
  <ItemFlags>0</ItemFlags>
 </Note>
 <Note>
  <ItemName>How to supply command line parameters</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <NoteLine>How to supply command line parameters</NoteLine>
   <NoteLine>`OptionParser` is versitle on it's use of command line options.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>* Options can appear anywhere on the command line</NoteLine>
   <NoteLine>* Extra can be at the start, middle or end of the command line</NoteLine>
   <NoteLine>* Short options can be combined</NoteLine>
   <NoteLine>* Long options with assignment utilize the equal sign (`=`)</NoteLine>
   <NoteLine>* Short options can optionally use the `=` sign</NoteLine>
   <NoteLine>* File and Directory options can be a full or relative path</NoteLine>
   <NoteLine>* Anything after a `--` is considered an extra even if it looks like a parameter</NoteLine>
   <NoteLine>* Boolean options can be prefixed with no, --recursive or --no-recursive, it'll</NoteLine>
   <NoteLine>  just do the right thing.</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>Here are some example uses at the command line:</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>```</NoteLine>
   <NoteLine># Options for a fictitious copy program</NoteLine>
   <NoteLine>#</NoteLine>
   <NoteLine># -r/--recursive</NoteLine>
   <NoteLine># -v/--verbose</NoteLine>
   <NoteLine># -l/--log FILE</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine># copy the $HOME/Desktop/Folder to /tmp recursively with verbose turned on</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>$ cp -rv ~/Desktop/Folder /tmp</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine># same thing</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>$ cp ~/Desktop/Folder -r /tmp -v</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine># enable logging to a file</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>$ cp -rv --log=file.txt ~/Desktop/Folder /tmp</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine># enable logging to a file using combined short options </NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>$ cp -rvl=file.txt ~/Desktop/Folder /tmp</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine># disable verbose and copy a file named "-r" to "tmp.txt"</NoteLine>
   <NoteLine></NoteLine>
   <NoteLine>$ cp --no-verbose -- -r tmp.txt</NoteLine>
   <NoteLine>```</NoteLine>
  </ItemSource>
  <ItemFlags>0</ItemFlags>
 </Note>
 <Property>
  <ItemName>AdditionalHelpNotes</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>AdditionalHelpNotes As String</SourceLine>
   <SourceLine>Displayed after the help message generated by `OptionParser` when the</SourceLine>
   <SourceLine>help screen is shown.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>This can be used to provide further usage notes and to expand on options</SourceLine>
   <SourceLine>when a single line description is not sufficient.</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>AdditionalHelpNotes As String</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <SetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Set</SourceLine>
   <SourceLine>mAdditionalHelpNotes = ReplaceLineEndings(value.Trim, EndOfLine)</SourceLine>
   <SourceLine>End Set</SourceLine>
  </SetAccessor>
  <GetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Get</SourceLine>
   <SourceLine>return mAdditionalHelpNotes</SourceLine>
   <SourceLine>End Get</SourceLine>
  </GetAccessor>
 </Property>
 <Property>
  <ItemName>AppDescription</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>AppDescription As String</SourceLine>
   <SourceLine>Typically a single line description of the application that is displayed</SourceLine>
   <SourceLine>before the application help.</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>AppDescription As String</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>AppName</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>AppName As String</SourceLine>
   <SourceLine>Name of the application. If empty, `OptionParser` will assign the `AppName`</SourceLine>
   <SourceLine>variable to the name of the executable filename. This is displayed when </SourceLine>
   <SourceLine>user help is shown.</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>AppName As String</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>Dict</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Dict As Dictionary</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Dict As Dictionary</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>Extra()</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Extra() As String</SourceLine>
   <SourceLine>Any non-option parameters given to the application will be appended</SourceLine>
   <SourceLine>to this array. For example:</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>```</SourceLine>
   <SourceLine>$ my-app --verbose -o ./docs file.txt file2.txt file3.txt</SourceLine>
   <SourceLine>```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>In the above case, the `Extras` array will contain three</SourceLine>
   <SourceLine>strings:</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>```</SourceLine>
   <SourceLine>0 = "file.txt"</SourceLine>
   <SourceLine>1 = "file2.txt"</SourceLine>
   <SourceLine>2 = "file3.txt"</SourceLine>
   <SourceLine>```</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Extra() As String</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>ExtrasRequired</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>ExtrasRequired As Integer</SourceLine>
   <SourceLine>Specify the minimum number of extra items required. For example, say you are</SourceLine>
   <SourceLine>writing a copy program. One might set this value to `2`.</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>```</SourceLine>
   <SourceLine>$ copy extra1 extra2</SourceLine>
   <SourceLine>```</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>See `Extra` for more information.</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>ExtrasRequired As Integer = 0</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>HelpRequested</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>HelpRequested As Boolean</SourceLine>
   <SourceLine>`True` when the user supplies either `-h` or `--help` on the command line.</SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>HelpRequested As Boolean</ItemDeclaration>
  <ItemFlags>0</ItemFlags>
  <IsShared>0</IsShared>
  <SetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Set</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Set</SourceLine>
  </SetAccessor>
  <GetAccessor>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Get</SourceLine>
   <SourceLine>Dim o As Option = OptionValue("help")</SourceLine>
   <SourceLine>If o Is Nil Then</SourceLine>
   <SourceLine>Return False // Should never happen</SourceLine>
   <SourceLine>Else</SourceLine>
   <SourceLine>Return o.WasSet</SourceLine>
   <SourceLine>End If</SourceLine>
   <SourceLine></SourceLine>
   <SourceLine>End Get</SourceLine>
  </GetAccessor>
 </Property>
 <Property>
  <ItemName>mAdditionalHelpNotes</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>mAdditionalHelpNotes As String</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>mAdditionalHelpNotes As String</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>Options()</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>Options() As Option</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>Options() As Option</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <Property>
  <ItemName>OriginalArgs()</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <ItemSource>
   <TextEncoding>134217984</TextEncoding>
   <SourceLine>OriginalArgs() As String</SourceLine>
   <SourceLine></SourceLine>
  </ItemSource>
  <TextEncoding>134217984</TextEncoding>
  <ItemDeclaration>OriginalArgs() As String</ItemDeclaration>
  <ItemFlags>33</ItemFlags>
  <IsShared>0</IsShared>
 </Property>
 <ViewBehavior>
  <ViewProperty>
   <ObjName>AdditionalHelpNotes</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <ItemType>String</ItemType>
   <EditorType>MultiLineEditor</EditorType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>AppDescription</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <ItemType>String</ItemType>
   <EditorType>MultiLineEditor</EditorType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>AppName</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <ItemType>String</ItemType>
   <EditorType>MultiLineEditor</EditorType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>ExtrasRequired</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>HelpRequested</ObjName>
   <PropertyGroup>Behavior</PropertyGroup>
   <ItemType>Boolean</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Index</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <PropertyValue>-2147483648</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Left</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Name</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Super</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>ID</PropertyGroup>
   <ItemType>String</ItemType>
  </ViewProperty>
  <ViewProperty>
   <ObjName>Top</ObjName>
   <Visible>1</Visible>
   <PropertyGroup>Position</PropertyGroup>
   <PropertyValue>0</PropertyValue>
   <ItemType>Integer</ItemType>
  </ViewProperty>
 </ViewBehavior>
 <Constant>
  <ItemName>kIndentPrefix</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>&#32;&#32;</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kInvalidKeyValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>key value is invalid</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
 <Constant>
  <ItemName>kMissingKeyValue</ItemName>
  <Compatibility></Compatibility>
  <Visible>1</Visible>
  <TextEncoding>134217984</TextEncoding>
  <ItemType>0</ItemType>
  <ItemDef>key value is missing</ItemDef>
  <ItemFlags>33</ItemFlags>
 </Constant>
</block>
</RBProject>
